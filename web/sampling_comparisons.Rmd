---
title: "Sampling Comparison"
author: "Logan Harris"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: show
---

```{r setup, child = 'web/_include/setup.rmd'}
```

```{r, message = FALSE, warning = FALSE, include=FALSE}
unloadNamespace("hdrm")
unloadNamespace("ncvreg")
res_dir <- switch(Sys.info()['user'],
                  'pbreheny' = '~/res/lasso-boot',
                  'loganharris' = '.')

.libPaths(paste0(res_dir, "/local"))
quietlyLoadPackage <- function(package) {
  suppressPackageStartupMessages(library(package, character.only = TRUE))
}

packages <- c("dplyr", "tidyr", "ggplot2", "ncvreg", "gridExtra", "scales", "kableExtra", "grid", "glue", "lme4")

.libPaths(paste0(res_dir, "/local"))
lapply(packages, quietlyLoadPackage)
colors <- palette()[c(2, 4, 3, 6, 7)]
sec_colors <- c("black", "grey62")
background_colors <- c("#E2E2E2", "#F5F5F5")

quantiles <- "disturbed"
method <- "quantile"
method_pretty <- c("mode" = "Traditional", "sample" = "Random Sample", "zs" = "Debias", "disturbed" = "Accept/Reject", "zerosample" = "Zero Sample")
```
# Method Comparison: Lapalce Simulation

## Coverage by Mangitude

```{r, message=FALSE, echo = FALSE}
## Load Data
load(glue("{res_dir}/rds/lassoboot_comparison_laplace_100_all_{method}_1000_2.rds"))

plots <- list()
method_pretty <- c("mode" = "Traditional", "sample" = "Random Sample", "zs" = "Debias", "disturbed" = "Accept/Reject", "zerosample" = "Zero Sample")

n_methods <- length(method_pretty)

library(mgcv)
library(splines)

cutoff <- 3
for (j in 1:3) {

  all_coverages_i <- res_coverage[[j]]
  model_res <- do.call(rbind, all_coverages_i) %>%
    data.frame() %>%
    pivot_longer(all_of(names(method_pretty)), names_to = "method", values_to = "covered") %>%
    mutate(mag_truth = abs(truth), covered = as.numeric(covered))

  methods <- unique(model_res$method)
  line_data <- list()
  line_data_avg <- list()
  for (i in 1:length(methods)) {
    tmp <- model_res %>%
      filter(method == methods[i])

    # fit <- lme4::glmer(covered ~ mag_truth + mag_truth^2 + (1|group), data = tmp, family = binomial, control = glmerControl(optimizer = "bobyqa"))
    fit <- gam(covered ~ s(mag_truth) + s(group, bs = "re"), data = tmp, family = binomial)
    # fit <- gam(covered ~ s(mag_truth), data = tmp, family = binomial)
    xs <- seq(0, cutoff, by = .01)
    # ys <- predict(fit, data.frame(mag_truth = xs, group = 101), type ="response", allow.new.levels = TRUE)
    ys <- predict(fit, data.frame(mag_truth = xs, group = 101), type ="response")
    # ys <- predict(fit, data.frame(mag_truth = xs), type ="response")
    line_data[[i]] <- data.frame(x = xs, y = ys, method = methods[i])

    if (i == 1) {
      density_data <- density(abs(tmp$truth), bw = .25, n = cutoff * 100 + 1, from = 0, to = cutoff)
      density_data <- data.frame(x = density_data$x, density = density_data$y)
    }
    line_data_avg[[i]] <- data.frame(avg = sum(ys * density_data$density) / sum(density_data$density), method = method_pretty[methods[i]])

  }

  line_data_avg <- do.call(rbind, line_data_avg)
  line_data <- do.call(rbind, line_data)


  plots[[j]] <- ggplot() +
    geom_line(data = line_data %>% mutate(method = method_pretty[method]), aes(x = x, y = y, color = method)) +
    geom_hline(data = line_data_avg, aes(yintercept = avg, color = method), linetype = 2) +
    geom_hline(aes(yintercept = .8), linetype = 1) +
    geom_area(data = density_data, aes(x = x, y = density / max(density)), fill = "grey", alpha = 0.5) +
    theme_bw() +
    xlab(expression(abs(beta))) +
    ylab(NULL) +
    annotate("text", x = 0.1, y = 0.1, label = paste0("N = ", ns[j]), size = 5) +
    coord_cartesian(ylim = c(0, 1)) +
    scale_color_manual(name = "Method", values = colors)


}

plots[[1]]
plots[[2]]
plots[[3]]
```

## Overall Coverage and Widths

```{r, echo = FALSE}
method_pretty <- c("mode" = "Traditional", "sample" = "Sample", "zs" = "Debias", "disturbed" = "Disturbed", "zerosample" = "Zero Sample")

## Other plots
p1 <- do.call(rbind, lapply(1:3, function(i) {
  t(sapply(res_coverage[[i]], function(x) apply(x[,3:7], 2, mean, na.rm = TRUE))) %>%
   # do.call(rbind, lapply(res_coverage[[i]], function(x) apply(x[,3,drop=FALSE], 2, mean, na.rm = TRUE))) %>%
    data.frame() %>%
    tidyr::pivot_longer(all_of(names(method_pretty)), names_to = "method", values_to = "coverage") %>%
    mutate(group = paste0(method, "-", ns[i]), ss = as.character(ns[i]))
})) %>%
  ggplot(aes(x = method_pretty[method], y = coverage, group = group, fill = ss)) +
  geom_boxplot() +
  geom_hline(yintercept = .8) +
  scale_fill_manual(values = colors, name = "Sample Size") +
  ylab("Average Coverage") + xlab(NULL) +
  theme_bw()


## On average provides intervals for about 10 variables

p2 <- do.call(rbind, lapply(1:3, function(i) {
  res <- res_time[[i]]
  colnames(res) <- names(method_pretty)
  res %>%
    data.frame() %>%
    tidyr::pivot_longer(all_of(names(method_pretty)), names_to = "method", values_to = "time") %>%
    mutate(group = paste0(method, "-", ns[i]), ss = as.character(ns[i]))
})) %>%
  ggplot(aes(x = method_pretty[method], y = log10(time), group = group, fill = ss)) +
  geom_boxplot() +
  scale_fill_manual(values = colors, name = "Sample Size") +
  ylab(expression(log10(time))) + xlab(NULL) +
  theme_bw()



p3 <- do.call(rbind, lapply(1:3, function(i) {
  res <- res_width[[i]]
  colnames(res) <- names(method_pretty)
  res %>%
    data.frame() %>%
    tidyr::pivot_longer(all_of(names(method_pretty)), names_to = "method", values_to = "width") %>%
    mutate(group = paste0(method, "-", ns[i]), ss = as.character(ns[i]))
})) %>%
  ggplot(aes(x = method_pretty[method], y = width, group = group, fill = ss)) +
  geom_boxplot() +
  scale_fill_manual(values = colors, name = "Sample Size") +
  ylab("Median Width") + xlab(NULL) +
  theme_bw()

## Get summaries of times failed / infinite width / number of variables selected for si

p4 <- do.call(rbind, lapply(1:3, function(i) {
  res <- res_lambda[[i]]
  colnames(res) <- names(method_pretty)
  res %>%
    data.frame() %>%
    tidyr::pivot_longer(all_of(names(method_pretty)), names_to = "method", values_to = "lambda") %>%
    mutate(group = paste0(method, "-", ns[i]), ss = as.character(ns[i]))
})) %>%
  ggplot(aes(x = method_pretty[method], y = lambda, group = group, fill = ss)) +
  geom_boxplot() +
  scale_fill_manual(values = colors, name = "Sample Size") +
  ylab(expression(lambda)) + xlab(NULL) +
  theme_bw()


glist <- list(p1, p2, p3, p4)

# glist[[2]] <- glist[[2]] +
#   theme(legend.position = c(0.2, 0.2))

glist[[1]]
## glist[[2]]
glist[[3]]
## glist[[4]]
```

## Relative to Traditional

### Relative Width

```{r, echo = FALSE}
cutoff <- 3
xs <- seq(0, cutoff, by = .01)
methods <- unique(all_info[[1]]$method)

plots <- list()
for (j in 1:3) {
  curr_info <- all_info[[j]]

  ref <- curr_info %>%
    data.frame() %>%
    filter(method == "mode") %>%
    mutate(baseline_width = upper - lower)

  curr_info <- all_info[[j]]
  plot_res <- list()

  for (i in 1:length(methods)) {
    samp <- curr_info %>%
      data.frame() %>%
      filter(method == methods[i]) %>%
      mutate(width = upper - lower)
    plot_data <- ref %>%
      inner_join(samp, by = c("group", "truth")) %>%
      mutate(mag_truth = abs(truth)) %>%
      mutate(width_diff = width - baseline_width)
    fit <- gam(width_diff ~ s(mag_truth) + s(group, bs = "re"), data = plot_data)
    ys <- predict(fit, data.frame(mag_truth = xs, group = 101), type ="response")
    # fit <- lmer(width_diff ~ ns(mag_truth, df = 4) + (1|group), data = plot_data)
    # ys <- predict(fit, data.frame(mag_truth = xs, group = 101), type ="response", allow.new.levels = TRUE)
    plot_res[[i]] <- data.frame(xs = xs, width_diff = ys, method = methods[i])
  }

  plots[[j]] <- do.call(rbind, plot_res) %>%
    ggplot(aes(x = xs, y = width_diff, color = method)) +
    geom_line() +
    theme_bw() +
    xlab(expression(abs(beta))) +
    ylab("Relative Width Increase") +
    scale_color_manual(name = "Method", values = colors) 
}


## Center
## Need to update this when each method is running under same random seed
bias_est <- function(estimate, lower, upper) {
  case_when(
    sign(estimate) == -1 ~ mean(c(lower, upper)) - estimate,
    sign(estimate) == 0 ~ -1*abs(mean(c(lower, upper))),
    sign(estimate) == 1 ~ estimate - mean(c(lower, upper))
  )
}

plots_bias <- list()
for (j in 1:3) {
  curr_info <- all_info[[j]]

  ref <- curr_info %>%
    data.frame() %>%
    filter(method == "mode") %>%
    rowwise() %>%
    mutate(baseline_bias = bias_est(estimate, lower, upper))
  xs <- seq(0, cutoff, by = .01)
  plot_res <- list()
  for (i in 1:length(methods)) {
    samp <- curr_info %>%
      data.frame() %>%
      filter(method == methods[i]) %>%
      rowwise() %>%
      mutate(bias = bias_est(estimate, lower, upper))
    plot_data <- ref %>%
      inner_join(samp, by = c("group", "truth")) %>%
      mutate(mag_truth = abs(truth)) %>%
      mutate(bias_diff = bias - baseline_bias)
    fit <- gam(bias_diff ~ s(mag_truth) + s(group, bs = "re"), data = plot_data)
    ys <- predict(fit, data.frame(mag_truth = xs, group = 101), type ="response")
    # fit <- lmer(bias_diff ~ ns(mag_truth, df = 4) + (1|group), data = plot_data)
    # ys <- predict(fit, data.frame(mag_truth = xs, group = 101), type ="response", allow.new.levels = TRUE)
    plot_res[[i]] <- data.frame(xs = xs, bias = ys, method = methods[i])
  }

  plots_bias[[j]] <- do.call(rbind, plot_res) %>%
    ggplot(aes(x = xs, y = bias, color = method)) +
    geom_line() +
    theme_bw() +
    xlab(expression(abs(beta))) +
    ylab("Relative Bias") +
    scale_color_manual(name = "Method", values = colors)
}


plots[[1]]
plots[[2]]
plots[[3]]
```

### Relative Bias

```{r, echo = FALSE}
plots_bias[[1]]
plots_bias[[2]]
plots_bias[[3]]
```

# Method Comparison: Sparse (epsilon)

```{r, echo = FALSE}
n <- 60
p <- 60
load(glue("{res_dir}/rds/method_comparison_traditional_n{n}_p{p}.rds"))

for (i in 1:length(methods)) {
ci <- ci.boot.ncvreg(res[[i]], method = method)
cov <- mean(ci$lower <= dat$beta & dat$beta <= ci$upper) ## Traditional
print(plot(res[[i]], n = 30, method = "quantile") +
  ggtitle(glue("{method_pretty[methods[i]]} - Coverage: {round(cov * 100, 1)} %")) +
  ylab(NULL) +
  theme(
    axis.ticks.y = element_blank(),
    axis.text.y = element_blank()
  ))
}
```


# Mathod Comparison: whoari

```{r, echo = FALSE}
load(glue("{res_dir}/rds/lassoboot_comparison_whoari.rds"))

## Plotting function
plot_ci_comparison <- function(cis, lambdas, n, p, methods, nvars = 20) {

  ci_df <- do.call(rbind, cis) %>% data.frame()
  lambda_method <- methods[!is.null(lambdas)]
  lab <- paste0("N: ", n, ", p: ", p, ", ", paste0(paste(lambda_method, round(lambdas, 3), sep = ": "), collapse = ", "))

  plot_vars <- list()
  for (current_method in unique(ci_df$method)) {
    plot_vars[[current_method]] <- ci_df %>%
      filter(method == current_method) %>%
      dplyr::arrange(desc(abs(estimate))) %>%
      slice_head(n = nvars) %>%
      pull(variable)
  }
  plot_vars <- unique(unlist(plot_vars))

  plot_res <- ci_df %>%
    filter(variable %in% plot_vars) %>%
    dplyr::arrange(desc(abs(estimate)))

  plot_res$variable <- factor(plot_res$variable, levels = rev(plot_vars))

  plot_res %>%
    ggplot() +
    geom_errorbar(aes(xmin = lower, xmax = upper, y = variable, color = method), alpha = .6) +
    geom_point(aes(x = estimate, y = variable, color = method), alpha = .6) +
    theme_bw() +
    ylab(NULL) + xlab(NULL) +
    scale_color_manual(name = "Method", values = colors) +
    theme(#legend.position = "none",
          legend.position = c(.9, .05),
          legend.justification = c("right", "bottom"),
          legend.box.just = "right",
          legend.margin = margin(6, 6, 6, 6),
          legend.background = element_rect(fill = "transparent"))

}

plot_ci_comparison(cis, lambdas, n, p, methods)
```

## Method Comparison: High Correlation

```{r, echo = FALSE}
## Load Data
n <- 50
p <- 25
quantiles <- "zerosample"
method <- "quantile"
load(glue("{res_dir}/rds/method_comparison_highcorr_100_{quantiles}_{method}_n{n}_p{p}.rds")) # n = 50

plot_ridge <- function(ridge_ci, n = 30, quiet = TRUE) {

  plot_res <- ridge_ci[-1,] %>%
    data.frame()

  plot_res$variable <- rownames(plot_res)
  plot_res <- plot_res %>%
    dplyr::arrange(desc(abs(estimate))) %>%
    head(n)

  plot_res$variable <- factor(plot_res$variable, levels = rev(plot_res$variable))

  plot_res %>%
    ggplot() +
    geom_errorbar(aes(xmin = lower, xmax = upper, y = variable)) +
    geom_point(aes(x = estimate, y = variable)) +
    theme_bw() +
    labs(y = "Variable", x = "Estimate")

}

## Ridge
ridge_res <- do.call(rbind, ridge_cis)
variables <- rownames(ridge_res)
p1 <- ridge_res %>%
  data.frame() %>%
  mutate(variable = variables) %>%
  filter(variable %in% c("A1", "B1", "N1")) %>%
  pivot_longer(Lower:Upper, names_to = "bound", values_to = "value") %>%
  ggplot() +
  geom_boxplot(aes(x = value, y = variable, color = bound)) +
  theme_bw() +
  coord_cartesian(xlim = c(-1, 2)) +
  theme(legend.position = "none",
        plot.background = element_rect(fill=background_colors[2])) +
  ylab(NULL) +
  xlab(NULL) +
  scale_color_manual(values = colors) +
  annotate("text", x = -0.8, y = 3.3, label = "Ridge", size = 5)

colnames(ridge_example) <- tolower(colnames(ridge_example))
p2 <- plot_ridge(ridge_example) +
  coord_cartesian(xlim = c(-1, 2)) +
  ylab(NULL) +
  xlab(NULL) +
  theme(plot.background = element_rect(fill=background_colors[2]))

## Lasso
p3 <- do.call(rbind, lasso_cis_s) %>%
  data.frame() %>%
  filter(variable %in% c("A1", "B1", "N1")) %>%
  mutate(group = rep(1:100, each = 3), group = paste0(variable, group)) %>%
  pivot_longer(lower:upper, names_to = "bound", values_to = "value") %>%
  ggplot() +
  geom_boxplot(aes(x = value, y = variable, color = bound)) +
  theme_bw() +
  coord_cartesian(xlim = c(-1, 2)) +
  theme(legend.position = "none", plot.background = element_rect(fill=background_colors[1])) +
  ylab(NULL) +
  xlab(NULL) +
  scale_color_manual(values = colors) +
  annotate("text", x = -0.8, y = 3.3, label = "Lasso", size = 5)

p4 <- plot(lasso_example_s, method = method) +
  coord_cartesian(xlim = c(-1, 2)) +
  ylab(NULL) +
  xlab(NULL) +
  theme(plot.background = element_rect(fill=background_colors[1]))

left_label <- textGrob("Variable", gp = gpar(fontsize = 12), rot = 90)
bottom_label <- textGrob("Interval Endpoint", gp = gpar(fontsize = 12))
grid.arrange(grobs = list(p1, p2, p3, p4), ncol = 2)
```

## Accross Lambda Coverage Sparse

```{r, echo = FALSE}
sec_colors <- c("black", "grey62")

## Load Data
load(paste0(res_dir, "/rds/across_lambda_coverage_sparse_zerosample_quantile.rds"))

# Create a new transformation for reversed log10
log10_trans <- function() {
  trans_new(name = 'rev_log10',
            transform = function(x) -log10(x),
            inverse = function(x) 10^(-x))
}

scaleFUN <- function(x) sprintf("%.1f", x)

make_plot <- function(plot_res) {

  plot_data <- plot_res$plot_data
  lambda_min <- plot_res$lambda_min
  n <- plot_res$n

  coverages <- plot_data %>%
    mutate(covered = truth >= lower & truth <= upper) %>%
    group_by(lambda) %>%
    summarise(coverage = mean(covered)) %>%
    ungroup()

  coverages_each <- plot_data %>%
    mutate(covered = truth >= lower & truth <= upper) %>%
    group_by(lambda, mag = abs(truth)) %>%
    summarise(coverage = mean(covered)) %>%
    ungroup()

  # Create a scaling factor based on the range of the primary axis
  scaling_factor <- max(plot_data$width)

  # Scale the 'coverage' data for plotting with 'geom_smooth()'
  coverages$scaled_coverage <- coverages$coverage * (scaling_factor / 1)
  coverages_each$scaled_coverage <- coverages_each$coverage * (scaling_factor / 1)

  ## "Selected via CV" = "blue", "Truth" = "red"
  ggplot() +
    scale_x_continuous(trans = log10_trans(),
                       breaks = trans_breaks('log10', function(x) 10^x),
                       labels = trans_format('log10', math_format(10^.x))) +
    geom_vline(xintercept = lambda_min, linetype = "dashed", color = sec_colors[2], linewidth = .5) +
    geom_line(data = coverages, aes(x = lambda, y = scaled_coverage), color = "grey") +
    geom_line(data = coverages_each, aes(x = lambda, y = scaled_coverage, group = mag, color = as.character(mag))) +
    geom_jitter(data = plot_data, aes(x = lambda, y = width, color = as.character(abs(truth))), alpha = .7, width = .05) +
    xlab(expression(lambda)) + ylab("Interval Width") +
    theme_bw() +
    scale_color_discrete(name = expression(abs(beta))) +
    scale_color_manual(values = colors, name = expression(abs(beta))) +
    scale_y_continuous(
      name = NULL,
      sec.axis = sec_axis(~ ., name = NULL,
                          breaks = seq(0, scaling_factor, by = scaling_factor/10),
                          labels = seq(0, 1, by = .10)),
      labels=scaleFUN
    ) +
    theme(axis.line.y.right = element_line(color = "grey"),
          axis.ticks.y.right = element_line(color = "grey"),
          axis.text.y = element_text(size = 9),
          axis.text.y.right = element_text(size = 9),
          legend.position = c(0.875, 0.125),
          legend.direction = "horizontal",
          legend.background = element_rect(fill = NA),
          legend.title = element_text(size = 10),
          legend.text = element_text(size = 8),
          legend.key.width = unit(0.6, "cm"),
          legend.key.height = unit(0.3, "cm")) +
    coord_cartesian(xlim = c(10^(.55), 10^(-2.55))) +
    annotate("text", x = 10^.5, y = max(plot_data$width)*.98, label = paste0("N = ", n), size = 3.5)

}

plots <- lapply(plot_res, make_plot)

plots[[1]] <- plots[[1]] +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank()
  )
plots[[2]] <- plots[[2]] +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
plots[[3]] <- plots[[3]] +
  xlab(expression(lambda))

library(grid)
left_label <- textGrob("Interval Widths", gp = gpar(fontsize = 12), rot = 90)
right_label <- textGrob("Coverage", gp = gpar(fontsize = 12), rot = 270)


grid.arrange(grobs = plots, ncol = 1, left = left_label, right = right_label)
```

