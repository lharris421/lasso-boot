---
title: "EB CI Simple Example"
author: "Logan Harris"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


This serves as a proof of concept that the method I am using for finding a confidence interval is indeed working... but that the main issue we run into is dealing with the numerical instability of the posterior.

I can't remember exactly how Patrick did this (stochastic or not) but I think this is sufficient for now especially seeing even this breaks down.

Editorial note: Finish this later by adding a range of example using different rng and a spectrum of sample sizes. It would also be nice here to have plot outputs of the prior and posteriors as examples. Or this may be better suited for the bayes simple so we can see it in a place where we are actually fitting the lasso.


```{r}
density_function <- function(x, rate, mean, sigma, n = 30) {

  prior <- log(dlaplace(x, rate = rate))
  llik <- ll(beta = x, mean = mean, sigma = sigma, n = n)
  return(exp(prior + llik))

}

density_function_normalized <- function(x, rate, mean, sigma, n = 30, normalizer) {

  prior <- log(dlaplace(x, rate = rate))
  llik <- ll(beta = x, mean = mean, sigma = sigma, n = n)
  return(exp(prior + llik - log(normalizer)))

}

obj_simple <- function(beta, post_mode, p, rate, mean, sigma, n = 30) {

  rng <- Inf
  denom <- integrate(
    density_function, lower = post_mode-rng, upper = post_mode+rng, rate, mean, sigma, n
  )$value

  if (p > .5) {
    prob <- integrate(
      density_function_normalized, lower = post_mode, upper = beta,
      rate = rate, mean = mean, sigma = sigma, n = n,
      normalizer = denom
    )$value
  } else {
    prob <- integrate(
      density_function_normalized, lower = beta, upper = post_mode,
      rate = rate, mean = mean, sigma = sigma, n = n,
      normalizer = denom
    )$value
  }

  sig <- abs((1-2*p))
  return((sig/2) - prob)

}


## Objective for integrating from lower and upper bounds
obj <- function(beta, p, mean, sigma, rate, bounds, multiplier = 1) {


  ## Determine normalizing constant
  denom <- integrate(
    density_function, lower = bounds[1], upper = bounds[2],
    rate = rate, mean = mean, sigma = sigma, xvar = xvar, multiplier = multiplier
  )$value

  if (p > .5) {
    prob <- integrate(
      density_function_normalized, lower = bounds[1], upper = beta,
      rate = rate, partial_residuals = partial_residuals, sigma = sigma, xvar = xvar,
      normalizer = denom, multiplier = multiplier
    )$value
  } else {
    prob <- integrate(
      density_function_normalized, lower = beta, upper = bounds[2],
      rate = rate, partial_residuals = partial_residuals, sigma = sigma, xvar = xvar,
      normalizer = denom, multiplier = multiplier
    )$value
    prob <- 1 - prob
  }

  return(p - prob)

}

post_quant <- function(conf, mean = 0, sigma = 1, rate = 1, n = 30) {
  
  ## Posterior plot
  xvals <- seq(-10, 10, by = .01)
  yvals <- density_function(xvals, rate, mean, sigma, n)
  post_mode <- xvals[which.max(yvals)]
  
  rng <- Inf
  denom <- integrate(
    density_function, lower = post_mode-rng, upper = post_mode+rng, rate, mean, sigma, n
  )$value
  print(denom)
  
  yvals <- density_function_normalized(xvals, rate, mean, sigma, n, denom)
  post_mode <- xvals[which.max(yvals)]
  
  ## Check
  print(integrate(
      density_function_normalized, lower = -rng, upper = rng,
      rate = rate, mean = mean, sigma = sigma, n = n,
      normalizer = denom
    )$value)
  
  upper <- uniroot(obj_simple, c(post_mode, post_mode + 10), post_mode, conf + (1 - conf)/2, rate, mean, sigma, n)
  lower <- uniroot(obj_simple, c(post_mode - 10, post_mode), post_mode, (1 - conf)/2, rate, mean, sigma, n)
  ci <- c(lower$root, upper$root)
  
  
  plot(xvals, yvals, type = "l")
  abline(v = ci, col = "red")
  
  return(ci)

}
```


```{r}
post_quant(.8, mean = 2, n = 10)
post_quant(.8, mean = 2, n = 30)
post_quant(.8, mean = 2, n = 100)
post_quant(.8, mean = 2, n = 300)
post_quant(.8, mean = 2, n = 500)
post_quant(.8, mean = 2, n = 700)
```

However, it does not break down if the true distribution is centered at zero:

```{r}
post_quant(.8, mean = 0, n = 300)
```

