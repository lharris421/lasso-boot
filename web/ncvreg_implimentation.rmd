---
title: "nvcreg implimentation"
author: "Logan Harris"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: show
---

```{r setup, child = 'web/_include/setup.rmd'}
```

```{r, eval=FALSE}
## install.packages("githubinstall")
## githubinstall::gh_install_packages("breheny/ncvreg", ref = "bootstrap")
```

# Other Functions

## Bootstrap Simulation

```{r}
boot_sim <- function(beta, n = 100, p = 60, b, nboot = 100, nsim = 100, progress = FALSE) {

  overall_cov <- numeric(nsim)
  indiv_cov <- matrix(nrow = nsim, ncol = p)

  if (progress) pb <- txtProgressBar(1, nsim, style = 3)

  for (iter in 1:nsim) {
    if (missing(b)) {
      dat <- gen_data(n = n, p = p, p1 = length(beta), beta = beta)  
    } else {
      dat <- genDataABN(n = n, p = p, a = length(beta), b = b, beta = beta)  
    }
    
    tbeta <- dat$beta
    boot <- boot.ncvreg(dat$X, dat$y, nboot = nboot, verbose = FALSE)
    ci <- ci.boot.ncvreg(boot)

    indiv_cov[iter,] <- tbeta >= ci$lower & tbeta <= ci$upper
    overall_cov[iter] <- mean(indiv_cov[iter,])

    if (progress) setTxtProgressBar(pb, iter)

  }

  return(list("overall_coverage" = overall_cov, "individual_coverage" = indiv_cov, "beta" = tbeta))

}
```

## Method Comparison

```{r}
plot_ci_comparison <- function(ci_df, nvars = 30) {

  plot_vars <- list()
  for (current_method in unique(ci_df$method)) {
    plot_vars[[current_method]] <- ci_df %>%
      filter(method == current_method) %>%
      dplyr::arrange(desc(abs(estimate))) %>%
      slice_head(n = nvars) %>%
      pull(variable)
  }
  plot_vars <- unique(unlist(plot_vars))

  plot_res <- ci_df %>%
    filter(variable %in% plot_vars) %>%
    dplyr::arrange(desc(abs(estimate)))

  plot_res$variable <- factor(plot_res$variable, levels = rev(plot_vars))

  gg <- plot_res %>%
    ggplot() +
    geom_errorbar(aes(xmin = lower, xmax = upper, y = variable, color = method), alpha = .6) +
    geom_point(aes(x = estimate, y = variable, color = method), alpha = .6) +
    theme_bw() +
    labs(y = "Variable", x = "Estimate")

  return(gg)

}
```

# One Covariate

## Beta = 0

### Single Interval

```{r}
set.seed(my_seed)
dat <- gen_data(n = 30, p = 1, beta = 0)
res <- boot.ncvreg(dat$X, dat$y, verbose = FALSE)
ci.boot.ncvreg(res)
```


### Coverage

```{r}
set.seed(my_seed)
mean(boot_sim(beta = 0, n = 30, p = 1)$overall_coverage)
```

## Beta = 3

### Single Interval

```{r}
set.seed(my_seed)
dat <- gen_data(beta = 3, n = 30, p = 1, p1 = 1)
ci.boot.ncvreg(boot.ncvreg(dat$X, dat$y, verbose = FALSE))
```


### Coverage

```{r}
set.seed(my_seed)
mean(boot_sim(beta = 3, n = 30, p = 1)$overall_coverage)
```

# Many Covariates 

## p = 60, n = 100

### Single Example


```{r}
set.seed(my_seed)
dat <- genDataABN(beta = c(2, 1, 0.5, -2, -1, -0.5), n = 100, p = 60, a = 6, b = 2)
plot(boot.ncvreg(dat$X, dat$y, verbose = FALSE))
```


### Coverage

```{r}
set.seed(my_seed)
res <- boot_sim(beta = c(2, 1, 0.5, -2, -1, -0.5), b = 2)
```

##### Overall Coverage (per bootstrap)

```{r}
mean(res$overall_coverage)
hist(res$overall_coverage, xlab = "Coverage", main ="")
```

##### Individual Coverage (per covariate)

```{r}
tmp <- data.frame(coverage = apply(res$individual_coverage, 2, mean) , beta = res$beta)
plot(abs(tmp$beta), tmp$coverage, xlab = "True Beta Value", ylab = "Coverage")
```

# Interval widths

```{r}
set.seed(my_seed)
dat <- hdrm::genDataABN(n = 100, p = 60, a = 6, b = 2, beta = c(-2, -1, -0.5, 0.5, 1, 2))

lambda_max <- max(ncvreg:::find_thresh(std(dat$X), dat$y))
lambda_min <- lambda_max * 0.001
lambda_max <- lambda_max - lambda_max*.01
lambda_min <- lambda_min + lambda_min*.01
lambda_seq <- 10^(seq(log(lambda_max, 10), log(lambda_min, 10), length.out = 10))

res <- list()
for (i in 1:length(lambda_seq)) {
  boot_res <- ncvreg:::boot.ncvreg(X = dat$X, y = dat$y, lambda = lambda_seq[i])
  res[[i]] <- ncvreg:::ci.boot.ncvreg(boot_res) %>%
    dplyr::mutate(width = upper - lower, lambda = lambda_seq[i]) %>%
    dplyr::select(variable, width, lambda, estimate) 
}
```

```{r}
truth <- data.frame(variable = names(dat$beta), truth = as.character(abs(dat$beta)))
red_res <- res

do.call("rbind", red_res) %>%
  left_join(truth) %>%
  ggplot(aes(x = lambda, y = width, color = truth)) +
  geom_jitter(alpha = .6, width = .05) +
  scale_x_continuous(
    trans = 'log10' 
  ) +
  xlab("Lambda") + ylab("Interval Width") +
  theme_bw() +
  scale_color_discrete(name = expression(abs(beta)))
```

# Comparison to Other Methods

## Generate Data

```{r}
set.seed(my_seed)
dat <- genDataABN(beta = c(2, 1, 0.5, -2, -1, -0.5), p = 60, a = 6, b = 2, n = 100)
dat$X <- std(dat$X)
```

## Selective Inference

```{r}
set.seed(my_seed)
cv_res <- cv.glmnet(dat$X, dat$y, standardize = FALSE)
lam <- cv_res$lambda.min

fit <- cv_res$glmnet.fit
b <- coef(fit, s = lam)[-1]
sh <- estimateSigma(dat$X, dat$y)$sigmahat
res <- fixedLassoInf(dat$X, dat$y, b, lam*length(dat$y), sigma=sh, alpha = .2)
bb <- res$vmat %*% dat$y
B <- cbind(bb, res$ci, res$pv)
rownames(B) <- names(res$vars)
B <- B[is.finite(B[,2]) & is.finite(B[,3]),-4]
si_abn <- B %>%
  data.frame(method = "Selective Inference", variable = rownames(B)) %>%
  rename(estimate = X1, lower = X2, upper = X3)
```

## HDI

```{r}
fit.lasso.allinfo <- boot.lasso.proj(dat$X, dat$y, return.bootdist = TRUE)
ci_hdi <- confint(fit.lasso.allinfo, level = 0.8)

hdi_abn <- ci_hdi %>%
  data.frame(method = "BLP", variable = rownames(ci_hdi)) %>%
  mutate(estimate = (lower + upper) / 2)
```

## Lasso Boot

```{r}
set.seed(my_seed)
abn <- boot.ncvreg(dat$X, dat$y, verbose = FALSE)

lassoboot_abn <- ci.boot.ncvreg(abn)
```

## Comparison

```{r}
ci_df <- bind_rows(si_abn, hdi_abn, lassoboot_abn)

gg <- plot_ci_comparison(ci_df)
gg + coord_cartesian(xlim=c(-3, 3))
```

# Function Checks

## Unstandardized X

```{r}
set.seed(my_seed)
dat <- genDataABN(beta = c(2, 1, 0.5, -2, -1, -0.5), p = 60, a = 6, b = 2, n = 100)
```


### Using cv.ncvreg as argument

```{r}
set.seed(my_seed)
tmp <- cv.ncvreg(dat$X, dat$y, penalty = "lasso", returnX = TRUE)
tst1 <- boot.ncvreg(cvncvreg = tmp)
tst1_ci <- ci.boot.ncvreg(tst1)
```


### Specifying data directly

```{r}
set.seed(my_seed)
tst2 <- boot.ncvreg(dat$X, dat$y)
tst2_ci <- ci.boot.ncvreg(tst2)
```

### Same?

```{r}
mean(abs(tst1$modes - tst2$modes) < 1e-12 | (is.na(tst1$modes) & is.na(tst2$modes)))
mean(abs(tst1$lowers - tst2$lowers) < 1e-12 | (is.na(tst1$lowers) & is.na(tst2$lowers)))
mean(abs(tst1$uppers - tst2$uppers) < 1e-12 | (is.na(tst1$uppers) & is.na(tst2$uppers)))
```

### Using function from before migration

```{r}
set.seed(my_seed)
tst3 <- eb_boot(dat = dat)
tst3_ci <- boot_ci(tst3)
```

### Same?

```{r}
mean(abs(tst1$lowers - tst3$lower) < 1e-12 | (is.na(tst1$lowers) & is.na(tst3$lower)))
mean(abs(tst1$uppers - tst3$upper) < 1e-12 | (is.na(tst1$uppers) & is.na(tst3$upper)))
```

## Standardized X

```{r}
dat$X <- std(dat$X)
```

### Using cv.ncvreg as argument

```{r}
set.seed(my_seed)
tmp <- cv.ncvreg(dat$X, dat$y, penalty = "lasso", returnX = TRUE)
tst1 <- boot.ncvreg(cvncvreg = tmp)
tst1_ci <- ci.boot.ncvreg(tst1)
```


### Specifying data directly

```{r}
set.seed(my_seed)
tst2 <- boot.ncvreg(dat$X, dat$y)
tst2_ci <- ci.boot.ncvreg(tst2)
```

### Same?

```{r}
mean(abs(tst1$modes - tst2$modes) < 1e-12 | (is.na(tst1$modes) & is.na(tst2$modes)))
mean(abs(tst1$lowers - tst2$lowers) < 1e-12 | (is.na(tst1$lowers) & is.na(tst2$lowers)))
mean(abs(tst1$uppers - tst2$uppers) < 1e-12 | (is.na(tst1$uppers) & is.na(tst2$uppers)))
```

### Using function from before migration

```{r}
set.seed(my_seed)
tst3 <- eb_boot(dat = dat)
tst3_ci <- boot_ci(tst3)
```

### Same?

```{r}
mean(abs(tst1$lowers - tst3$lower) < 1e-12 | (is.na(tst1$lowers) & is.na(tst3$lower)))
mean(abs(tst1$uppers - tst3$upper) < 1e-12 | (is.na(tst1$uppers) & is.na(tst3$upper)))
```
