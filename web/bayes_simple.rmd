---
title: "Simple Bayes"
output:
  html_document:
    code_folding: hide
---

```{r setup, child = 'web/_include/setup.rmd'}
```

# Through quantile functions

```{r}
dlaplace <- function(x, rate = 1) {
  dexp(abs(x), rate) / 2
} 

qlaplace <- function(p, rate = 1) {
  if (p <= .5) {
    p <- (.5 - p)*2
    qexp(p, rate)*-1
  } else {
    p <- (p - .5)*2
    qexp(p, rate)
  }
}

rlaplace <- function(n, rate = 1) {
  rexp(n, rate) * sample(c(-1, 1), n, replace = TRUE)
}
```



```{r}
ll <- function(beta, partial_residuals, sigma, xvar) {
  
  # Compute the log-likelihood(s)
  tmp <- sapply(beta, function(x) sum(dnorm(partial_residuals - xvar*x, mean = 0, sd = sigma, log = TRUE)))
  return(tmp)
  
}


obj <- function(beta, p, sigma, rate, xvar, partial_residuals) {
  
  denom <- integrate(
    function(x) {
      prior <- log(dlaplace(x, rate = rate))
      llik <- ll(beta = x, partial_residuals, sigma, xvar)
      exp(prior + llik)
    }, lower = -Inf, upper = Inf, subdivisions = 1e4)
  
  ## print(integrate(function(x) exp(log(dlaplace(x, rate)) + ll(x, partial_residuals, sigma, xvar))*(1/denom$value), lower = -Inf, upper = Inf, subdivisions = 1e4)$value)
  abs(p - integrate(function(x) exp(log(dlaplace(x, rate)) + ll(x, partial_residuals, sigma, xvar))*(1/denom$value), lower = -Inf, upper = beta, subdivisions = 1e4)$value)
  
}

post_quant <- function(p, sigma, rate, x, partial_residuals) {
  tmp <- optimize(obj, lower = -10, upper = 10, p = p, sigma = sigma, rate = rate, xvar = x, partial_residuals = partial_residuals)
  print(tmp)
  return(tmp$minimum)
}

```

```{r}
eb_boot <- function(beta, p = 60, b = 2, n = 100, niter = 100) {
  
  ## set.seed(12345)
  dat <- genDataABN(beta = beta, p = p, a = length(beta), b = b, n = n)
  
  tbeta <- dat$beta
  X <- dat$X
  y <- dat$y
  
  lowers <- matrix(nrow = niter, ncol = length(tbeta))
  uppers <- matrix(nrow = niter, ncol = length(tbeta))
  for (i in 1:niter) {
    
    idx_new <- sample(1:length(y), replace = TRUE)
    ynew <- y[idx_new]
    xnew <- X[idx_new,,drop=FALSE]
    
    cv_res <- cv.ncvreg(xnew, ynew, penalty = "lasso")
    sigma2 <- cv_res$cve[cv_res$lambda == cv_res$lambda.min]
    lam <- cv_res$lambda.min
    coefs <- coef(cv_res$fit, lambda = lam)
    rate <- (lam*n / sigma2)
    
    ## Beta specific
    for (j in 1:length(tbeta)) {
      
      r <- ynew - (coefs[1] + xnew[,-j] %*% coefs[-1][-j])
      
      lowers[i,j] <- post_quant(.1, sqrt(sigma2), rate, xnew[,j,drop=FALSE], r) 
      uppers[i,j] <- post_quant(.9, sqrt(sigma2), rate, xnew[,j,drop=FALSE], r)
      
    }
    
  }
  
  return(list("lower" = lowers, "upper" = uppers, "truth" = tbeta))
  
}


```

```{r}
beta0 <- eb_boot(beta = 0, p = 1, b = 0, n = 100, niter = 10)
```

```{r}
beta0
```

